for (def sourceSet in [sourceSets.main, sourceSets.client]) {
	// We have to capture the source set name for the lazy string literals,
	// otherwise it'll just be whatever the last source set is in the list.
	def sourceSetName = sourceSet.name
	def taskName = sourceSet.getTaskName('validate', 'Annotations')
	def task = tasks.register(taskName, ValidateAnnotations) {
		group = 'fabric'
		description = "Validate annotations for $sourceSetName packages."

		// Only apply to default source directory since there's also generated package-info files.
		setSource file("src/$sourceSetName/java")
	}
	tasks.check.dependsOn task
}

class ValidateAnnotations extends SourceTask {
	private static final def API_STATUS_INTERNAL = ~/@ApiStatus\.Internal/
	private static final def ENVIRONMENT = ~/@Environment/

	@TaskAction
	def run() {
		for (def dir in ['api', 'impl', 'mixin']) {
			getSource().matching { include "net/fabricmc/fabric/$dir/" }.forEach {
				if (it.isDirectory()) {
					return
				}

				def contents = it.text

				// @Environment is never allowed
				if (ENVIRONMENT.matcher(contents).find()) {
					throw new RuntimeException("Found @Environment annotation in file: $it")
				}

				// @ApiStatus.Internal is only allowed in api packages (it's auto-generated for impl packages)
				if (dir != "api") {
					if (API_STATUS_INTERNAL.matcher(contents).find()) {
						throw new RuntimeException("Found @ApiStatus.Internal in implementation file: " + it)
					}
				}
			}
		}
	}
}
