import java.nio.file.Files

task generateImplPackageInfos(type: GenerateImplPackageInfos) {
	group = 'fabric'
	description = 'Generates package-info files for implementation packages.'

	for (def sourceSet in [sourceSets.main, sourceSets.client]) {
		sourceRoots.from sourceSet.java.srcDirs
	}

	header = rootProject.file('HEADER')
	outputDir = file('src/generated/java')
}

sourceSets.main.java.srcDir generateImplPackageInfos.outputDir

class GenerateImplPackageInfos extends DefaultTask {
	@InputFile File header
	@InputFiles final ConfigurableFileCollection sourceRoots = project.objects.fileCollection()
	@OutputDirectory final DirectoryProperty outputDir = project.objects.directoryProperty()

	@TaskAction
	def run() {
		def output = outputDir.get().asFile.toPath()
		output.deleteDir()
		def headerText = header.readLines().join("\n") // normalize line endings

		for (def sourceRoot in sourceRoots) {
			def root = sourceRoot.toPath()

			for (def dir in ['impl', 'mixin']) {
				def implDir = root.resolve("net/fabricmc/fabric/$dir")

				if (Files.notExists(implDir)) {
					continue
				}

				implDir.eachDirRecurse {
					def containsJava = Files.list(it).any {
						Files.isRegularFile(it) && it.fileName.toString().endsWith('.java')
					}

					if (containsJava && Files.notExists(it.resolve('package-info.java'))) {
						def relativePath = root.relativize(it)
						def target = output.resolve(relativePath)
						Files.createDirectories(target)

						target.resolve('package-info.java').withWriter {
							def packageName = relativePath.toString().replace(File.separator, '.')
							it.write("""$headerText
							|/**
							| * Implementation code for ${project.name}.
							| */
							|@ApiStatus.Internal
							|package $packageName;
							|
							|import org.jetbrains.annotations.ApiStatus;
							|""".stripMargin())
						}
					}
				}
			}
		}
	}
}
